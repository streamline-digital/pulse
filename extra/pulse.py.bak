import argparse
import datetime
import subprocess
import time
import re
import itertools

def parse_schedule(schedule_str):

    fields = schedule_str.split('.')

    if len(fields) != 6:

        raise ValueError("Invalid schedule format. Use YYYY.MM.DD.HH.mm.ss")

    return fields


def is_schedule_match(current_time, schedule):
    for i in range(6):
        if schedule[i] != '*' and current_time[i] not in schedule[i]:
            return False
    return True

def expand_field(i, field):

    maximum_expansions = [None, 12, None, 24, 60, 60]
    
    if '-' in field:

        start, end = map(int, field.strip('[]').split('-'))

        values = list(range(start, end + 1))

    elif ',' in field:

        values = [int(val) for val in field.strip('[]').split(',')]

    elif field == "*":

        if i != 2: values = list(range(1,maximum_expansions[i]+1))

        else: values = ["*"]

    else:

        values = [int(field)]

    return values

def parse(schedule):

    number_of_days_in_months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

    times = []

    schedule = [expand_field(i, field) for i, field in enumerate(schedule)]

    
    for month in schedule[1]:

        days = list(range(1, number_of_days_in_months[month-1]+1))
        t = [schedule[0], [month], days, schedule[3], schedule[4], schedule[5]]

        times += list(itertools.product(*t))

    return times

def main():

    parser = argparse.ArgumentParser(description='Run shell commands at specified intervals.')
    parser.add_argument('schedule', help='Scheduling syntax: YYYY.MM.DD.HH.mm.ss')
    parser.add_argument('command', help='Shell command to be executed in double quotes')

    args = parser.parse_args()

    try:

        schedule = parse_schedule(args.schedule)

    except ValueError as e:

        print(f"Error: {e}")

        return

    schedule = parse(schedule)

    print(schedule)

    print(f"Scheduled command '{args.command}' to run at {args.schedule}")

    while True:

        current_time = [int(val) for val in datetime.datetime.now().strftime('%Y.%m.%d.%H.%M.%S').split('.')]

        for time in schedule:

            if time == current_time:

                subprocess.run(args.command, shell=True)
                print(f"Executed command at {datetime.datetime.now()}")

        #time.sleep(1)

if __name__ == "__main__":

    main()

